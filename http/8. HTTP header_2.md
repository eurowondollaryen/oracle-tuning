## 8. HTTP 헤더-캐시와 조건부 요청
### HTTP 캐시
#### 캐시 기본 동작 - 캐시가 없을 때
1. GET /star.jpg 요청한다.
2. 서버는 star.jpg 이미지를 응답한다. (1.1MB) (헤더 0.1M, 바디 1.0M)
3. 또 요청하면 1.1MB의 데이터를 다시 응답한다.
> 로딩 속도 느림, 네트워크 비용 증가, 느린 사용자 경험

#### 캐시 기본 동작 - 캐시 적용
1. 서버에서 cache-control: max-age=60(60초) 헤더를 추가하여 응답한다.
2. 최초 요청 시에는 서버에서 파일을 보내준다. 클라이언트(브라우저)는 캐시에 저장한다.
3. 해당 리소스를 서버에 요청하기 전에, 브라우저에서 찾아 쓴다.
> 장점은 위 캐시가 없을 경우의 반대.

#### 캐시 기본 동작 - 캐시 시간 초과
- 만약 캐시 유효 시간이 초과되면? 당연히 다시 서버에 요청하고, 캐시를 갱신한다.
> 근데, 리소스가 변경되지 않았는데, 캐시가 만료 되었다면.. 또 받을 필요가 있을까?..

### 8-2. 검증 헤더와 조건부 요청
- 캐시 리소스가 만료되었을 때, 경우의 수는 다음 2가지.
- 만료된 캐시 리소스가 진짜 바뀌었을 경우
- 만료된 캐시 리소스가 바뀌지 않았을 경우
> 리소스가 같다는 것을 확인할 수 있는 방법이 필요하다. 이것을 검증 헤더가 수행함.

1. 클라이언트가 헤더에 다음 내용을 추가한다. Last-Modified: 2020/11/10 ...
2. 캐시 유효시간(60초)이 지남.
3. 클라이언트가 if-modified-since: 2020/11/10 ...
4. 서버는 if-modified-since 헤더를 보고, 실제 리소스랑 비교를 해서, 데이터 수정 시간이 동일하면, 리소스가 신선하다고 판단.
5. 서버는 304 Not Modified로 response를 한다. 근데 HTTP Body가 없다.(수정된 것이 없기 때문에)

#### 검증 헤더, 조건부 요청 정리
- Last-Modified: 검증 헤더
- If-Modified-Since: 조건부 요청
- 캐시 유효시간이 초과해도 데이터 갱신되지 않으면, 304 Not Modified, 헤더 메타 정보만 응답한다.
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 아닌 HTTP 헤더만 받게 된다.

#### 검증 헤더, 조건부 요청
- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified, ETag
- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
  - If-Modified-Since: Last-Modified 의 조건부 요청에 사용
  - If-None-Match: ETag 의 조건부 요청에 사용
  - 조건이 만족하면 200 OK
  - 조건이 만족하지 않으면 304 Not Modified

#### 예시
- If-Modified-Since: 해당 시간 이후에 데이터가 수정되었으면? (서버 최종수정시간이 클라이언트 이후면?)
  - 수정되었으면 200 OK (헤더, 바디 모두 전송, 수정되지 않았으면 304 Not Modified (헤더만 전송)

#### Last-Modified-Since 단점
- 1초 미만으로는 캐시 조정 불가.
- 날짜 기반의 로직을 사용하므로, 만약 데이터를 똑같이 수정했는데, 날짜만 변경되었다면? 컨텐츠가 같음에도 불과하고 다시 받아진다.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우? (변경 있어도, 중요한 변경이 없으면 캐시를 유지할래)

#### ETag, If-None-Match
- ETag(Entity Tag): 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.(데이터를 hash하거나, 임의로 만들어서 활용.)
- 단순하게 클라이언트->서버로 ETag만 보내서 같으면 클라 캐시 유지, 다르면 갱신.

#### ETag, If-None-Match 정리
- 캐시 제어 로직을 서버에서 완전히 관리한다.
- 클라이언트는 단순히 ETag 값을 서버에 제공하므로, 서버에서 어떤 식으로 캐시를 주는지 모름.
> 애플리케이션 배포 주기에 맞춰서 ETag를 모두 갱신(실무에서 이런식으로 함)


### 8-3. 캐시와 조건부 요청 헤더
#### 캐시 제어 헤더
- Cache-Control 캐시 제어
  - Cache-Control: max-age 
    - 캐시 유효 시간, 초 단위(유효 시간동안만 캐시 담아서 써라)
  - Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용 (If-Modified-Since 또는 If-None-Match를 이용해서 검증하고 사용해라)
  - Cache-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨.(메모리에서 사용하고 최대한 빨리 삭제해라. 캐시는 하드에 보통 저장되므로, 저장 x)
  
- Pragma 캐시 제어(하위 호환)
  - Pragma: no-cache
  - HTTP 1.0 하위 호환

- Expires 캐시 만료일 지정(하위 호환)
  - expires: [GMT기준 일시]
  - 캐시 만료일을 정확한 날짜로 지정
  - HTTP 1.0부터 사용
  - 지금은 더 유연한 Cache-Control: max-age를 권장
  - Cache-Control: max-age와 함께 사용하면 Expires는 무시한다.
  > 일자를 정하는 것 보다, 유효시간을 넣는 게 더 유연하게 쓸 수 있다.


### 8-4. 프록시 캐시
#### 예시
- origin 서버(원래의 리소스가 있는 서버) (미국)
- 클라이언트 (한국)
> 물리적으로 시간이 오래 걸리므로, 리소스를 한국에 있는 프록시 캐시 서버를 통해 제공받을 수 있도록 한다.
> 유튜브에서 사람들이 잘 안 보는 외국 컨텐츠를 보면 느림.. 주로 cdn 서비스를 이용함.
> 최초로 리소스에 접근하는 유저한테는 느리다.
> 프록시 캐시 서버에 있는 캐시를 public 캐시, 내 로컬에 저장되는 캐시를 private 캐시라고 한다.

#### Cache-Control
- Cache-Control: public
  - 응답이 public에 저장되어도 된다.
- Cache-Control: private
  - 응답이 해당 사용자만을 위한 것, private 캐시에 저장해야 한다.(기본)
> 아래 두 가지는 참고.
- Cache-Control: s-maxage
  - 프록시 캐시에만 적용되는 최대 수명
- Age: 60
  - origin 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)

### 8-5. 캐시 무효화
- 캐시는 캐시 설정하지 않으면 안 되는게 아님. 브라우저가 알아서 할 수 있음.
- 절대 캐시가 되면 안 되는 리소스에 대해서는 캐시 무효화를 해야한다.

#### 캐시 무효화 관련 헤더값들
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
  > 프록시 캐시 - 원 서버 간의 통신이 단절되면?..
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨.(메모리에서 사용하고 최대한 빨리 삭제)
- Cache-Control: must-revalidate
  - 캐시 만료 후 최초 조회 시 원 서버에 검증해야 한다.
  - 원 서버 접근 실패 시 반드시 오류가 발생해야 함. - 504(Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용한다.
- Pragma: no-cache
  - HTTP 1.0 하위 호환
  > 옛날 브라우저를 위한 옵션

#### no-cache 기본 동작
1. 클라이언트 -> 프록시 캐시 (no-cache + ETag)
2. 프록시 캐시 -> 원 서버 (no-cache + ETag)
3. 원 서버에서 검증 후 304 Not Modified로 응답

#### no-cache 네트워크 단절일 경우(프록시 캐시 - 원서버)
1. 클라이언트 -> 프록시 캐시 (no-cache + ETag)
2. no-cache(원 서버에 접근할 수 없는 경우, 캐시 서버 설정에 따라 캐시 데이터를 반환할 수 있다.)
   Error 또는 200 OK를 반환한다.(오류 보다는 오래된 데이터라도 보여주자.)
3. 프록시 캐시 -> 클라이언트 200 OK

#### must-revalidate 네트워크 단절일 경우(프록시 캐시 - 원서버)
1. 클라이언트 -> 프록시 캐시 (must-revalidate + ETag)
2. must-revalidate(원 서버에 접근할 수 없는 경우, 항상 오류가 발생해야 한다. - 504 Gateway Timeout)
3. 프록시 캐시 -> 클라이언트 504 Gateway Timeout